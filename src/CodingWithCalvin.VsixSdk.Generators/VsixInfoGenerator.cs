using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace CodingWithCalvin.VsixSdk.Generators;

/// <summary>
/// Source generator that creates a VsixInfo class from the VSIX manifest file.
/// </summary>
[Generator]
public class VsixInfoGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all .vsixmanifest files in AdditionalFiles
        var manifestFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".vsixmanifest", StringComparison.OrdinalIgnoreCase));

        // Combine with compilation to get namespace
        var compilationAndManifests = context.CompilationProvider
            .Combine(manifestFiles.Collect());

        context.RegisterSourceOutput(compilationAndManifests, (ctx, source) =>
        {
            var (compilation, manifests) = source;

            foreach (var manifest in manifests)
            {
                GenerateVsixInfo(ctx, compilation, manifest);
            }
        });
    }

    private static void GenerateVsixInfo(
        SourceProductionContext context,
        Compilation compilation,
        AdditionalText manifestFile)
    {
        var text = manifestFile.GetText(context.CancellationToken);
        if (text == null) return;

        try
        {
            var doc = new XmlDocument();
            doc.LoadXml(text.ToString());

            var nsmgr = new XmlNamespaceManager(doc.NameTable);
            nsmgr.AddNamespace("vsix", "http://schemas.microsoft.com/developer/vsx-schema/2011");

            // Extract metadata
            var metadata = new VsixMetadata
            {
                Id = GetAttributeValue(doc, "//vsix:Identity/@Id", nsmgr),
                Version = GetAttributeValue(doc, "//vsix:Identity/@Version", nsmgr),
                Language = GetAttributeValue(doc, "//vsix:Identity/@Language", nsmgr),
                Publisher = GetAttributeValue(doc, "//vsix:Identity/@Publisher", nsmgr),
                DisplayName = GetElementText(doc, "//vsix:DisplayName", nsmgr),
                Description = GetElementText(doc, "//vsix:Description", nsmgr),
                MoreInfo = GetElementText(doc, "//vsix:MoreInfo", nsmgr),
                License = GetElementText(doc, "//vsix:License", nsmgr),
                GettingStartedGuide = GetElementText(doc, "//vsix:GettingStartedGuide", nsmgr),
                ReleaseNotes = GetElementText(doc, "//vsix:ReleaseNotes", nsmgr),
                Icon = GetElementText(doc, "//vsix:Icon", nsmgr),
                PreviewImage = GetElementText(doc, "//vsix:PreviewImage", nsmgr),
                Tags = GetElementText(doc, "//vsix:Tags", nsmgr),
                IsPreview = GetElementText(doc, "//vsix:Preview", nsmgr)?.Equals("true", StringComparison.OrdinalIgnoreCase) ?? false
            };

            // Get namespace from compilation
            var rootNamespace = compilation.AssemblyName ?? "GeneratedCode";

            var source = GenerateSource(rootNamespace, metadata);
            context.AddSource("VsixInfo.g.cs", SourceText.From(source, Encoding.UTF8));
        }
        catch (Exception ex)
        {
            // Report diagnostic on error
            var descriptor = new DiagnosticDescriptor(
                "VSIXSDK001",
                "Failed to parse VSIX manifest",
                "Failed to parse VSIX manifest: {0}",
                "VsixSdk",
                DiagnosticSeverity.Warning,
                isEnabledByDefault: true);

            context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, ex.Message));
        }
    }

    private static string? GetAttributeValue(XmlDocument doc, string xpath, XmlNamespaceManager nsmgr)
    {
        var node = doc.SelectSingleNode(xpath, nsmgr);
        return node?.Value;
    }

    private static string? GetElementText(XmlDocument doc, string xpath, XmlNamespaceManager nsmgr)
    {
        var node = doc.SelectSingleNode(xpath, nsmgr);
        return node?.InnerText;
    }

    private static string GenerateSource(string rootNamespace, VsixMetadata metadata)
    {
        var sb = new StringBuilder();
        sb.AppendLine("//------------------------------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine("//     This code was generated by CodingWithCalvin.VsixSdk from the VSIX manifest.");
        sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
        sb.AppendLine("//     the code is regenerated.");
        sb.AppendLine("// </auto-generated>");
        sb.AppendLine("//------------------------------------------------------------------------------");
        sb.AppendLine();
        sb.AppendLine($"namespace {rootNamespace}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Provides compile-time constants from the VSIX manifest metadata.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    internal static class VsixInfo");
        sb.AppendLine("    {");
        sb.AppendLine($"        /// <summary>The unique identifier of the extension.</summary>");
        sb.AppendLine($"        public const string Id = \"{EscapeString(metadata.Id)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>The version of the extension.</summary>");
        sb.AppendLine($"        public const string Version = \"{EscapeString(metadata.Version)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>The language/locale of the extension.</summary>");
        sb.AppendLine($"        public const string Language = \"{EscapeString(metadata.Language)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>The publisher/author of the extension.</summary>");
        sb.AppendLine($"        public const string Publisher = \"{EscapeString(metadata.Publisher)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>The display name of the extension.</summary>");
        sb.AppendLine($"        public const string DisplayName = \"{EscapeString(metadata.DisplayName)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>The description of the extension.</summary>");
        sb.AppendLine($"        public const string Description = \"{EscapeString(metadata.Description)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>URL for more information about the extension.</summary>");
        sb.AppendLine($"        public const string MoreInfo = \"{EscapeString(metadata.MoreInfo)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>Path to the license file.</summary>");
        sb.AppendLine($"        public const string License = \"{EscapeString(metadata.License)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>URL to the getting started guide.</summary>");
        sb.AppendLine($"        public const string GettingStartedGuide = \"{EscapeString(metadata.GettingStartedGuide)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>URL or path to release notes.</summary>");
        sb.AppendLine($"        public const string ReleaseNotes = \"{EscapeString(metadata.ReleaseNotes)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>Path to the extension icon.</summary>");
        sb.AppendLine($"        public const string Icon = \"{EscapeString(metadata.Icon)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>Path to the preview image.</summary>");
        sb.AppendLine($"        public const string PreviewImage = \"{EscapeString(metadata.PreviewImage)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>Comma-separated tags for the extension.</summary>");
        sb.AppendLine($"        public const string Tags = \"{EscapeString(metadata.Tags)}\";");
        sb.AppendLine();
        sb.AppendLine($"        /// <summary>Whether the extension is marked as a preview release.</summary>");
        sb.AppendLine($"        public const bool IsPreview = {(metadata.IsPreview ? "true" : "false")};");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string EscapeString(string? value)
    {
        if (string.IsNullOrEmpty(value)) return string.Empty;
        return value!.Replace("\\", "\\\\").Replace("\"", "\\\"");
    }

    private class VsixMetadata
    {
        public string? Id { get; set; }
        public string? Version { get; set; }
        public string? Language { get; set; }
        public string? Publisher { get; set; }
        public string? DisplayName { get; set; }
        public string? Description { get; set; }
        public string? MoreInfo { get; set; }
        public string? License { get; set; }
        public string? GettingStartedGuide { get; set; }
        public string? ReleaseNotes { get; set; }
        public string? Icon { get; set; }
        public string? PreviewImage { get; set; }
        public string? Tags { get; set; }
        public bool IsPreview { get; set; }
    }
}
