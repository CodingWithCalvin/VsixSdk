<Project>
  <!--
    CodingWithCalvin.VsixSdk - Sdk.Vsix.targets

    VSIX-specific targets. Can be imported standalone or as part of the full SDK.
  -->

  <!--
    Default item includes for VSIX projects
    These can be disabled with EnableDefaultVsixItems=false
  -->
  <ItemGroup Condition="'$(EnableDefaultVsixItems)' != 'false' and '$(EnableDefaultItems)' != 'false'">

    <!-- Include VSCT files (Visual Studio Command Table) -->
    <VSCTCompile Include="**/*.vsct"
                 Condition="'$(EnableDefaultVsctItems)' != 'false'"
                 Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)">
      <ResourceName>$(VSCTResourceName)</ResourceName>
    </VSCTCompile>

    <!-- Include VSPackage resource files -->
    <EmbeddedResource Include="**/VSPackage.resx"
                      Condition="'$(EnableDefaultVSPackageResourceItems)' != 'false'"
                      Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)">
      <MergeWithCTO>true</MergeWithCTO>
      <ManifestResourceName>VSPackage</ManifestResourceName>
    </EmbeddedResource>

    <!-- Include localized VSPackage resources -->
    <EmbeddedResource Include="**/VSPackage.*.resx"
                      Condition="'$(EnableDefaultVSPackageResourceItems)' != 'false'"
                      Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder);**/VSPackage.resx">
      <MergeWithCTO>true</MergeWithCTO>
      <DependentUpon>VSPackage.resx</DependentUpon>
    </EmbeddedResource>

    <!-- Include Image Manifest files for VS Image Service -->
    <ImageManifest Include="**/*.imagemanifest"
                   Condition="'$(EnableDefaultImageManifestItems)' != 'false'"
                   Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)">
      <IncludeInVSIX>true</IncludeInVSIX>
    </ImageManifest>

    <!-- Include Content Manifest files -->
    <Content Include="**/ContentManifest.json"
             Condition="'$(EnableDefaultContentManifestItems)' != 'false'"
             Exclude="$(DefaultItemExcludes);$(DefaultExcludesInProjectFolder)">
      <IncludeInVSIX>true</IncludeInVSIX>
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
    </Content>

  </ItemGroup>

  <PropertyGroup>
    <!-- Detect the source manifest location -->
    <_SourceVsixManifestPath Condition="'$(_SourceVsixManifestPath)' == '' and Exists('$(MSBuildProjectDirectory)\source.extension.vsixmanifest')">$(MSBuildProjectDirectory)\source.extension.vsixmanifest</_SourceVsixManifestPath>
    <_SourceVsixManifestPath Condition="'$(_SourceVsixManifestPath)' == '' and Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).vsixmanifest')">$(MSBuildProjectDirectory)\$(MSBuildProjectName).vsixmanifest</_SourceVsixManifestPath>
  </PropertyGroup>

  <!--
    Add VSIX manifest and VSCT files as AdditionalFiles for source generators.
    The generators use these to produce VsixInfo.g.cs and *Vsct.g.cs files.
  -->
  <ItemGroup>
    <!-- Add VSIX manifest for VsixInfoGenerator -->
    <AdditionalFiles Include="$(_SourceVsixManifestPath)" Condition="'$(_SourceVsixManifestPath)' != '' and Exists('$(_SourceVsixManifestPath)')" />

    <!-- Add VSCT files for VsctGuidsGenerator -->
    <AdditionalFiles Include="@(VSCTCompile)" />

    <!-- Keep source manifest visible in Solution Explorer for editing -->
    <None Include="$(_SourceVsixManifestPath)" Condition="'$(_SourceVsixManifestPath)' != '' and Exists('$(_SourceVsixManifestPath)')">
      <SubType>Designer</SubType>
    </None>
  </ItemGroup>

  <!--
    Version override support
    Usage: dotnet build -p:SetVsixVersion=2.5.0

    When SetVsixVersion is specified on the command line:
    1. Updates the source manifest with the new version
    2. Spawns a new MSBuild process that re-evaluates and builds with the updated manifest
    3. Creates a sentinel file to prevent the outer build from overwriting the VSIX

    This is necessary because VSSDK reads the manifest during evaluation phase,
    before any targets run. A new process re-evaluates and reads the updated manifest.

    Note: Use SetVsixVersion (not VsixVersion) because VsixVersion has a default value.
  -->
  <PropertyGroup>
    <_VsixVersionSentinel>$(IntermediateOutputPath)_vsix_version_build.sentinel</_VsixVersionSentinel>
  </PropertyGroup>

  <Target Name="BuildWithVsixVersion"
          BeforeTargets="PrepareForBuild"
          Condition="'$(SetVsixVersion)' != '' and '$(_VsixVersionBuildInProgress)' != 'true' and '$(_SourceVsixManifestPath)' != '' and Exists('$(_SourceVsixManifestPath)')">

    <PropertyGroup>
      <_VsixNsForPoke>&lt;Namespace Prefix='vsix' Uri='http://schemas.microsoft.com/developer/vsx-schema/2011'/&gt;</_VsixNsForPoke>
    </PropertyGroup>

    <!-- Update the source manifest -->
    <XmlPoke XmlInputPath="$(_SourceVsixManifestPath)"
             Query="/vsix:PackageManifest/vsix:Metadata/vsix:Identity/@Version"
             Value="$(SetVsixVersion)"
             Namespaces="$(_VsixNsForPoke)" />

    <Message Importance="high" Text="Updated VSIX manifest version to $(SetVsixVersion)" />

    <!-- Create sentinel to mark that inner build will produce the correct VSIX -->
    <MakeDir Directories="$(IntermediateOutputPath)" Condition="!Exists('$(IntermediateOutputPath)')" />
    <WriteLinesToFile File="$(_VsixVersionSentinel)" Lines="$(SetVsixVersion)" Overwrite="true" />

    <!-- Spawn new MSBuild process that will re-evaluate and read the updated manifest -->
    <Exec Command="dotnet build &quot;$(MSBuildProjectFullPath)&quot; -c $(Configuration) -p:_VsixVersionBuildInProgress=true --no-restore"
          WorkingDirectory="$(MSBuildProjectDirectory)" />

    <Message Importance="high" Text="VSIX build with version $(SetVsixVersion) completed." />
  </Target>

  <!-- Skip CreateVsixContainer when sentinel exists (outer build - inner build already created VSIX) -->
  <Target Name="_SkipVsixContainerForOuterBuild"
          BeforeTargets="CreateVsixContainer"
          Condition="'$(SetVsixVersion)' != '' and '$(_VsixVersionBuildInProgress)' != 'true' and Exists('$(_VsixVersionSentinel)')">
    <Message Importance="high" Text="Skipping VSIX creation in outer build (already created by inner build)." />
    <!-- Clear the inputs so CreateVsixContainer has nothing to do -->
    <ItemGroup>
      <VSIXSourceItem Remove="@(VSIXSourceItem)" />
    </ItemGroup>
  </Target>

  <!-- Clean up sentinel after outer build completes -->
  <Target Name="_CleanupVsixVersionSentinel"
          AfterTargets="Build"
          Condition="'$(SetVsixVersion)' != '' and '$(_VsixVersionBuildInProgress)' != 'true' and Exists('$(_VsixVersionSentinel)')">
    <Delete Files="$(_VsixVersionSentinel)" />
  </Target>

  <!--
    Target to validate VSIX project configuration
    Runs early in the build to catch common mistakes
  -->
  <Target Name="ValidateVsixConfiguration" BeforeTargets="BeforeBuild">
    <!-- Warn if targeting x86 (VS 2022 is 64-bit) -->
    <Warning Condition="'$(PlatformTarget)' == 'x86'"
             Text="Visual Studio 2022 is 64-bit. Consider changing PlatformTarget to 'AnyCPU'." />

    <!-- Warn if no VSIX manifest found -->
    <Warning Condition="!Exists('$(MSBuildProjectDirectory)\source.extension.vsixmanifest') and !Exists('$(MSBuildProjectDirectory)\$(MSBuildProjectName).vsixmanifest')"
             Text="No .vsixmanifest file found. VSIX projects require a manifest file." />
  </Target>

  <!--
    Generate launchSettings.json for F5 debugging
    Only runs when building inside Visual Studio and the file doesn't exist
    This configures VS to launch devenv.exe with the experimental instance
  -->
  <Target Name="GenerateLaunchSettings"
          BeforeTargets="BeforeBuild"
          Condition="'$(BuildingInsideVisualStudio)' == 'true' and '$(DevEnvDir)' != '' and !Exists('$(MSBuildProjectDirectory)\Properties\launchSettings.json')">

    <PropertyGroup>
      <!-- Escape backslashes for JSON -->
      <_DevEnvDirEscaped>$([System.String]::Copy('$(DevEnvDir)').Replace('\','\\'))</_DevEnvDirEscaped>
      <_LaunchSettingsContent><![CDATA[{
  "profiles": {
    "Debug Extension": {
      "commandName": "Executable",
      "executablePath": "$(_DevEnvDirEscaped)devenv.exe",
      "commandLineArgs": "/rootSuffix Exp"
    }
  }
}]]></_LaunchSettingsContent>
    </PropertyGroup>

    <MakeDir Directories="$(MSBuildProjectDirectory)\Properties" Condition="!Exists('$(MSBuildProjectDirectory)\Properties')" />
    <WriteLinesToFile File="$(MSBuildProjectDirectory)\Properties\launchSettings.json"
                      Lines="$(_LaunchSettingsContent)"
                      Overwrite="true" />

    <Message Importance="high" Text="Generated Properties/launchSettings.json for F5 debugging" />
  </Target>

  <!-- Import template support targets -->
  <Import Project="$(MSBuildThisFileDirectory)Sdk.Vsix.Templates.targets" />

  <!--
    Import VSSDK targets if available
    This is the key integration point with Microsoft.VSSDK.BuildTools
  -->
  <PropertyGroup>
    <!-- Allow users to skip VSSDK import -->
    <ImportVsSDKTargets Condition="'$(ImportVsSDKTargets)' == ''">true</ImportVsSDKTargets>

    <!-- Path to VsSDK targets from the NuGet package -->
    <VsSDKTargetsPath Condition="'$(VsSDKTargetsPath)' == '' and '$(VsSDKInstall)' != ''">$(VsSDKInstall)</VsSDKTargetsPath>
  </PropertyGroup>

  <!-- Import Microsoft.VsSDK.targets from VSSDK.BuildTools package -->
  <Import Project="$(VsSDKTargetsPath)\Microsoft.VsSDK.targets"
          Condition="'$(ImportVsSDKTargets)' == 'true' and '$(VsSDKTargetsPath)' != '' and Exists('$(VsSDKTargetsPath)\Microsoft.VsSDK.targets')" />

  <!-- Fallback: Import from CustomAfterMicrosoftCSharpTargets if set -->
  <Import Project="$(CustomAfterMicrosoftCSharpTargets)"
          Condition="'$(ImportVsSDKTargets)' == 'true' and '$(CustomAfterMicrosoftCSharpTargets)' != '' and Exists('$(CustomAfterMicrosoftCSharpTargets)')" />


</Project>
